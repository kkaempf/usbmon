#
# lib/usbmon/ftdi.rb
#
# 'Interpreter' for usbmon dumps talking to a FTDI usb-serial device
#
# UsbMon::Event
#     attr_reader :urb, :timestamp, :utd, :bus, :device, :endpoint, :status, :dlen, :dtag, :data
#
DECODE = { 0x00=>0xf6, 0x01=>0x09, 0x02=>0x89, 0x03=>0x0b, 0x04=>0x8b, 0x05=>0x0d, 0x06=>0x8d, 0x07=>0x0f, 0x08=>0x8f, 0x09=>0x01, 0x0a=>0x81, 0x0b=>0x03, 0x0c=>0x83, 0x0d=>0x05, 0x0e=>0x85, 0x0f=>0x07, 0x10=>0x87, 0x11=>0x19, 0x12=>0x99, 0x13=>0x1b, 0x14=>0x9b, 0x15=>0x1d, 0x16=>0x9d, 0x17=>0x1f, 0x18=>0x9f, 0x19=>0x11, 0x1a=>0x91, 0x1b=>0x13, 0x1c=>0x93, 0x1d=>0x15, 0x1e=>0x95, 0x1f=>0x17, 0x20=>0x97, 0x21=>0x29, 0x22=>0xa9, 0x23=>0x2b, 0x24=>0xab, 0x25=>0x2d, 0x26=>0xad, 0x27=>0x2f, 0x28=>0xaf, 0x29=>0x21, 0x2a=>0xa1, 0x2b=>0x23, 0x2c=>0xa3, 0x2d=>0x25, 0x2e=>0xa5, 0x2f=>0x27, 0x30=>0xa7, 0x31=>0x39, 0x32=>0xb9, 0x33=>0x3b, 0x34=>0xbb, 0x35=>0x3d, 0x36=>0xbd, 0x37=>0x3f, 0x38=>0xbf, 0x39=>0x31, 0x3a=>0xb1, 0x3b=>0x33, 0x3c=>0xb3, 0x3d=>0x35, 0x3e=>0xb5, 0x3f=>0x37, 0x40=>0xb7, 0x41=>0x49, 0x42=>0xc9, 0x43=>0x4b, 0x44=>0xcb, 0x45=>0x4d, 0x46=>0xcd, 0x47=>0x4f, 0x48=>0xcf, 0x49=>0x41, 0x4a=>0xc1, 0x4b=>0x43, 0x4c=>0xc3, 0x4d=>0x45, 0x4e=>0xc5, 0x4f=>0x47, 0x50=>0xc7, 0x51=>0x59, 0x52=>0xd9, 0x53=>0x5b, 0x54=>0xdb, 0x55=>0x5d, 0x56=>0xdd, 0x57=>0x5f, 0x58=>0xdf, 0x59=>0x51, 0x5a=>0xd1, 0x5b=>0x53, 0x5c=>0xd3, 0x5d=>0x55, 0x5e=>0xd5, 0x5f=>0x57, 0x60=>0xd7, 0x61=>0x69, 0x62=>0xe9, 0x63=>0x6b, 0x64=>0xeb, 0x65=>0x6d, 0x66=>0xed, 0x67=>0x6f, 0x68=>0xef, 0x69=>0x61, 0x6a=>0xe1, 0x6b=>0x63, 0x6c=>0xe3, 0x6d=>0x65, 0x6e=>0xe5, 0x6f=>0x67, 0x70=>0xe7, 0x71=>0x79, 0x72=>0xf9, 0x73=>0x7b, 0x74=>0xfb, 0x75=>0x7d, 0x76=>0xfd, 0x77=>0x7f, 0x78=>0xff, 0x79=>0x71, 0x7a=>0xf1, 0x7b=>0x73, 0x7c=>0xf3, 0x7d=>0x75, 0x7e=>0xf5, 0x7f=>0x77, 0x80=>0xf7, 0x81=>0x08, 0x82=>0x88, 0x83=>0x0a, 0x84=>0x8a, 0x85=>0x0c, 0x86=>0x8c, 0x87=>0x0e, 0x88=>0x8e, 0x89=>0x00, 0x8a=>0x80, 0x8b=>0x02, 0x8c=>0x82, 0x8d=>0x04, 0x8e=>0x84, 0x8f=>0x06, 0x90=>0x86, 0x91=>0x18, 0x92=>0x98, 0x93=>0x1a, 0x94=>0x9a, 0x95=>0x1c, 0x96=>0x9c, 0x97=>0x1e, 0x98=>0x9e, 0x99=>0x10, 0x9a=>0x90, 0x9b=>0x12, 0x9c=>0x92, 0x9d=>0x14, 0x9e=>0x94, 0x9f=>0x16, 0xa0=>0x96, 0xa1=>0x28, 0xa2=>0xa8, 0xa3=>0x2a, 0xa4=>0xaa, 0xa5=>0x2c, 0xa6=>0xac, 0xa7=>0x2e, 0xa8=>0xae, 0xa9=>0x20, 0xaa=>0xa0, 0xab=>0x22, 0xac=>0xa2, 0xad=>0x24, 0xae=>0xa4, 0xaf=>0x26, 0xb0=>0xa6, 0xb1=>0x38, 0xb2=>0xb8, 0xb3=>0x3a, 0xb4=>0xba, 0xb5=>0x3c, 0xb6=>0xbc, 0xb7=>0x3e, 0xb8=>0xbe, 0xb9=>0x30, 0xba=>0xb0, 0xbb=>0x32, 0xbc=>0xb2, 0xbd=>0x34, 0xbe=>0xb4, 0xbf=>0x36, 0xc0=>0xb6, 0xc1=>0x48, 0xc2=>0xc8, 0xc3=>0x4a, 0xc4=>0xca, 0xc5=>0x4c, 0xc6=>0xcc, 0xc7=>0x4e, 0xc8=>0xce, 0xc9=>0x40, 0xca=>0xc0, 0xcb=>0x42, 0xcc=>0xc2, 0xcd=>0x44, 0xce=>0xc4, 0xcf=>0x46, 0xd0=>0xc6, 0xd1=>0x58, 0xd2=>0xd8, 0xd3=>0x5a, 0xd4=>0xda, 0xd5=>0x5c, 0xd6=>0xdc, 0xd7=>0x5e, 0xd8=>0xde, 0xd9=>0x50, 0xda=>0xd0, 0xdb=>0x52, 0xdc=>0xd2, 0xdd=>0x54, 0xde=>0xd4, 0xdf=>0x56, 0xe0=>0xd6, 0xe1=>0x68, 0xe2=>0xe8, 0xe3=>0x6a, 0xe4=>0xea, 0xe5=>0x6c, 0xe6=>0xec, 0xe7=>0x6e, 0xe8=>0xee, 0xe9=>0x60, 0xea=>0xe0, 0xeb=>0x62, 0xec=>0xe2, 0xed=>0x64, 0xee=>0xe4, 0xef=>0x66, 0xf0=>0xe6, 0xf1=>0x78, 0xf2=>0xf8, 0xf3=>0x7a, 0xf4=>0xfa, 0xf5=>0x7c, 0xf6=>0xfc, 0xf7=>0x7e, 0xf8=>0xfe, 0xf9=>0x70, 0xfa=>0xf0, 0xfb=>0x72, 0xfc=>0xf2, 0xfd=>0x74, 0xfe=>0xf4, 0xff=>0x76 }

module UsbMon
  #
  # tty device settings
  #
  class FtdiControl
    def initialize stream, utd
#      puts "FtdiControl"
      @stream = stream
      case utd
      when "Ci"
        @msg = ControlIn.new @stream
        submission_device_to_vendor @msg
      when "Co"
        @msg = ControlOut.new @stream
        submission_vendor_to_device @msg
      else
        raise "FtdiControl: unexpected utd #{utd.inspect}"
      end
#      puts "FtdiControl #{@event}"
    end
    def flag s, v
      s + ((v == 0) ? " LOW" : " HIGH")
    end
    def submission_vendor_to_device msg
      event = msg.event
      case event.bRequest
      when 0
        case event.wValue
        when 0
          printf "reset T%dmsec", event.timestamp/1000
        when 1
          puts "flush rx"
        when 2
          puts "flush tx"
        else
          printf "reset %02x\n", event.wValue
        end
      when 1
        dtr = (event.wValue >> 8) & 0x01
        rts = (event.wValue >> 8) & 0x02
        printf "set control T%dmsec 0x%04x[0x%04x]: %s %s\n", event.timestamp/1000, event.wValue, event.wIndex, flag("DTR", dtr), flag("RTS", rts)
      when 2
        puts "flow control"
      when 3
        # see linux ftdi_sio.c:ftdi_232bm_baud_to_divisor()
        # assuming a FT232RL chip here
        #
        div_value = event.wValue + (event.wIndex<<16)
#        printf "div_value orig %08x\n", div_value;
        base = 48000000 / 2
        # Deal with special cases for highest baud rates.
        if div_value == 1
          div_value = 0x4001
        elsif div_value == 0
          div_value = 1
        end
#        printf "div_value normalized %08x\n", div_value;
        # now reverse this (from ftdi_sio.c):
        #   int divisor3 = base / 2 / baud;
        #   divisor = divisor3 >> 3;
        #   divisor |= (__u32)divfrac[divisor3 & 0x7] << 14;               
        divfrac = { 0=>0, 3=>1, 2=>2, 4=>3, 1=>4, 5=>5, 6=>6, 7=>7 }
        idx = (div_value >> 14) & 0x07
#        printf "idx %02x[%04x], divfrag = %d\n", idx, div_value & ~0x03ff, divfrac[idx];
        div_value = (div_value & 0x03fff)
#        printf "div_value no frac %04x\n", div_value;
        divisor = (div_value << 3) + divfrac[idx];
#        printf "divisor\n", divisor;
        baud = base / divisor
        printf "set baudrate 0x%04x[0x%04x] %d\n", event.wValue, event.wIndex, baud
      when 4
        break_v = (event.wValue >> 14) & 0x01
        stop_bits = ["0","1.5","2","?"][(event.wValue >> 11) & 0x03]
        parity = ["N","O","E","M","S","<5>","<6>","<7>"][(event.wValue >> 8) & 0x07]
        bits = event.wValue & 0x0f
        printf "set data 0x%04x[0x%04x] #{bits}#{parity}#{stop_bits}, brk #{break_v}\n", event.wValue, event.wIndex
      when 6
        puts "set event char"
      when 7
        puts "set error char"
      when 8
        puts "set latency timer"
      else
        printf "0x40 0x%02x\n", event.bRequest
      end
    end
    def submission_device_to_vendor msg
      event = msg.event
      case event.bRequest
      when 0x90
        puts "read register"
      when 0x91
        puts "write register"
      when 0x92
        puts "erase register"
      when 0x05
        puts "get modem status #{msg.length}:#{msg.data}"
        raise "Modem status got #{msg.length} bytes" unless msg.length == 2
        # get modem and line status
        mstatus,lstatus = [msg.data].pack('H*').split('').map { |c| c.ord }
        cts = ((mstatus & 0x10) != 0) ? "CTS" : ""
        dsr = ((mstatus & 0x20) != 0) ? "DSR" : ""
        ri = ((mstatus & 0x40) != 0) ? "RI" : ""
        rlsd = ((mstatus & 0x80) != 0) ? "RLSD" : ""
        dr = ((lstatus & 0x01) != 0) ? "DtaRdy" : ""
        oe = ((lstatus & 0x02) != 0) ? "Overrun" : ""
        pe = ((lstatus & 0x04) != 0) ? "ParityErr" : ""
        fe = ((lstatus & 0x08) != 0) ? "FrmErr" : ""
        bi = ((lstatus & 0x10) != 0) ? "BrkInt" : ""
        the = ((lstatus & 0x20) != 0) ? "TrnsHldReg" : ""
        te = ((lstatus & 0x40) != 0) ? "TrnsEmpty" : ""
        re = ((lstatus & 0x80) != 0) ? "RcvErr" : ""               
        printf "modem status [%02x] %s %s %s %s", mstatus, cts, dsr, ri, rlsd
        printf "line status [%02x] %s %s %s %s %s %s %s %s\n", lstatus, dr, oe, pe, fe, bi, the, te, re
      when 0x0a
        puts "get latency timer"
      else
        printf "0xc0 0x%02x\n", event.bRequest
      end
    end
    def submission event
      puts event
      case event.bmRequestType
      when 0x40
        submission_vendor_to_device event
      when 0xc0
        submission_device_to_vendor event
      else
        printf "submission type 0x%02x\n", event.bmRequestType
      end
    end
  end
  #
  # Receive
  #
  class FtdiRx
    def initialize stream
#      puts "FtdiRx"
      @stream = stream
      @event = BulkIn.new @stream
      unless @event.data == "3160" # filter out ftdi heartbeat
        data = @event.data
        if data[0,4] == "3160"
#          puts "heartbeat #{@event.data.inspect}"
          data = data[4..-1]  # filter out ftdi heartbeat
#          puts "filtered #{data.inspect}"
        end
        data = [data].pack('H*').split('').map { |c| DECODE[c.ord] }
        puts "FtdiRx #{data.map{|c| ((c & 0x7f)>=32) ? c.chr : '.'}.join('')}: #{data.map{|d| d.chr.unpack('H*')}.join(' ')}"
      end
    end
  end
  #
  # Transmit
  #
  class FtdiTx
    def initialize stream
      @stream = stream
      @event = BulkOut.new @stream
#      puts "FtdiTx #{@event.inspect}"
      data = [@event.data].pack('H*').split('').map { |c| DECODE[c.ord] }
      puts "FtdiTx T#{@event.event.timestamp/1000}msec #{data.map{|c| ((c & 0x7f)>=32) ? c.chr : '.'}.join('')}: #{data.map{|d| d.chr.unpack('H*')}.join(' ')}"
    end
  end
  class Ftdi
    attr_reader :bus, :device
    def initialize eventstream, digits = []
      @stream = eventstream
      if digits.empty?
        puts "not found - please specify bus and device"
        exit 1
      else
        require 'scanf'
        @bus = digits.shift.scanf("%d")[0]
        @device = digits.shift.scanf("%d")[0]
        puts "searching at #{@bus}:#{@device}"
      end
    end
    
    def debug= level
      @debug = level if level > 0
    end
    #
    # consume event stream
    #
    def consume
      @stream.bus = @bus
      @stream.device = @device
      loop do
        begin
          msg = @stream.get
#          puts "Ftdi.consume #{msg.lnum}: #{msg.bus}:#{msg.device}:#{msg.endpoint}[#{msg.utd.inspect}]: #{msg}"
          #
          # Enpoint 0: control, 1: Rx, 2: Tx
          #
          @stream.unget msg
          case msg.endpoint
          when 0
            FtdiControl.new @stream, msg.utd
          when 1
            FtdiRx.new @stream
          when 2
            FtdiTx.new @stream
          else
            puts "Unknown endpoint #{msg.endpoint} for #{msg}"
          end
        rescue IOError
          raise
        rescue Exception => e
          puts "Failed at line #{@stream.lnum} with #{e}"
          puts msg
          puts e.backtrace
          break
        end
      end
    end
  end
end
